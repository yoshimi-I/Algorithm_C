# 連結リスト
## 概要
- 配列は追加、削除をする場合にそれ以外の値の配列を全て前に持ってきたり、後ろに持ってきたりと全配列に参照する必要があり計算量も無駄にかかってします
- そこで登場するのが連結リストという考え方である
- 簡単に説明すると値を格納したメモリ同士が離れていても、そのメモリ各々に次のメモリのポインタを保持させておくことで次の値を参照することができ、実質配列のように扱うことができるというものである。
## 具体的な実装方法
- 簡単にいうと格納するint型の値と次のメモリのポインタのアドレス値を保持するセルを用意する
    - これは構造体を用いて実装する
    ```
    struct list{
        int id;
        struct list *next;
    }
    ```
    - また構造体の他に先頭のアドレスを表すポインタ変数,メモリの追加によって追加したメモリのポインタを表すポインタ変数を用意する
    ```
    struct list *head_p; //構造体の他に先頭のアドレスを表すポインタ変数
    struct list *cell_p; //メモリの追加によって追加したメモリのポインタを表すポインタ変数
    ```
## メモリの確保
- 値を追加などするときは新しいメモリを確保する必要が出てくるが、その時に使うのがmalloc関数である
```
#include <stdlib.h>
void *malloc(size_t);
```
- 引数にはメモリのサイズをバイト単位で指定する。
- またメモリのアドレスを返却するため,返却値の型は
    -  void*とはどんな型のポインタも指定することができる(int,char,floatなんでも)
    ```
    char* p
    p  = (char*) marroc(size);  //以下に詳細解説
    ```
    - marrocの前の(char*)は本来マロックはvoid型のポインタ型を返すため自分の使う型のポインタ値にキャストする必要がありその役割を持つ
    - これはchar分のサイズのメモリを確保してそのポインタ値を引数としてとる
    - これで確保できる場所をヒープ領域という
## 様々な種類のリスト
- 循環リスト
    - 最終要素をnullにするのではなく、先頭の配列のポインタを渡すことでループ構造を持たせる
- 双方向リスト
    - 次の要素のアドレスと前の要素のアドレスを保持する
## 配列と比較した時のメリットデメリット
- 配列より優れているのはデータの挿入、削除であり
- 配列の方が優れているのはデータへのアクセスである

    | 操作内容       | 配列 | 構造体 | 
    | -------------- | ---- | ------ | 
    | データアクセス | O(1) | O(n)   | 
    | データ挿入/削除 | O(n) | O(1)   | 